# 1.1 Getting Started

- Computer science is terribly broad:
    - Distributed-systems
    - Artificial Intelligence
    - Robotics
    - Computer Graphics
    - Security
    - Scientific-computing
    - Comp-architecture
- Few parts of human life is unaffected. The following are domains of computations:
    - Commerce
    - Communications
    - Science
    - Art
    - Leisure
    - Politics
- Why is computer science powerful? Because of elegant and powerful fundamental ideas:
    1. Represent information
    2. Specify logic to process it
    3. Design abstractions that manage the complexity of that logic
- Such ideas everything computing, computer, and computer science have long been taught using SICP.
- This book borrows heavily from that textbook.

> You must learn how computers interpret programs and carry out the computational process

## 1.1.1 Programming in Python
- Python will be used to define computational processes because both man and machine can understand it
- Pythonistas:
    - Web-developers
    - Game-developers
    - Scientists
    - Academics
    - Language-designers
    - Million-person-strong community
- Developer communities:
    - solve problems
    - share projects and experience
    - develop software and tools
- The language is a large open-source project. It was started by Guido van Rossum in the late 80s
- The Zen of Python guides by the principles of beauty, simplicity, and readability
- Good for learning because of readability and features which enable numerous programming styles
- The SICP fashion dictates that Python will be introduced step-by-step with techniques for:
    - abstraction
    - rigorous model of computation

## 1.1.2 Installing Python 3
- *Python 3 will be used in this book*

## 1.1.3 Interactive Sessions
- *just some REPL-ing*

## 1.1.4 First Example
- *Python* will be introduced by building up language knowledge piece-by-piece
- Capabilities of Python:
    - Text-manipulation
    - Displaying graphics
    - Internet communications
- *Python code* consists of these things:
    1. Statements are actions which are carried out
    2. Expressions are computations which are evaluated
    - both either to compute some value or to carry out some action
- *Functions* are encapsulations of data-manipulating logic
    - *Functions are the feature of this chapter*
- *Objects* are complexity-managing bundles of data and logic used to manipulate said data
    - *Objects are featured in chapter 2*
- *Interpreters* are programs that interpret human-readable code.
    - They carry out statements and evaluate expressions.
    - *Interpreters are featured in chapter 3*
- Computer programs do not compare to the unique generality of interpreters. The Python interpreter allows inherently cumbersome code to be expressed in small volumes.
- All of the aforementioned concepts are related:
    - functions are objects
    - objects are functions
    - interpreters are both at the same time
- *Strive to develop the fundamental philosophy behind each of these concepts to master the art of programming.*

## 1.1.5 Errors
- Computers are fast as they are rigid.
- Within Stanford's introductory course (CS101):
    - The fundamental equation of computers is:
        - powerful + stupid
    - Computers can process tremendous volumes of data and perform billions of operations per second.
    - Computers are also extremely stupid and fragile. All it takes is one unhandled error or uncaught exception to cease operations and crash the computer.
- Programming is about a person constructing useful things out of the tiny, simple little operations that a computer can do using their personal insights.
- Many unexpected errors are caused by simple spelling and formatting mistakes within the code.
- Debugging is the process of interpreting and diagnosing errors. It is mostly guided by the following principles.
    1. Test incrementally
        - Divide the program into manageable subcomponents which must be debugged ASAP before continuing development.
    2. Isolate errors
        - Trace errors to the smallest fragment of code located within the particular modular component attributed by the error-output.
    3. Check your assumptions
        - Unexpected behavior can and will with time, arise from the programmer's false assumption and insight used to write the code and generate the program.
    4. Consult others
        - Research.
        - Procure enabling knowledge from external resources and then return to the problem at hand. Ask either man or machine.
- Test incrementally, design out of modularity, use critical assumptions, and teamwork to make the dreamwork.
- *Let such themes persist in your computer science career.*
